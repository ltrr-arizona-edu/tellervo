/*******************************************************************************
 * Copyright (C) 2001 Ken Harris
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Contributors:
 *     Peter Brewer
 ******************************************************************************/

package org.tellervo.desktop.print;


import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Font;
import java.awt.print.PageFormat;

import org.tellervo.desktop.util.StringUtils;

// TODO: decimal alignment.  for example, "{.}" should align to a
// decimal point, and "{/*}" should align to either '*' or '/'.

/**
 A factory for printing tables, using fixed tab-stops.

 <p>The way it works is: you give it a specification for the lines you'll
 be adding, and then use the factory for creating those lines.</p>

 <p>When you create a factory, you feed it a specification string.
 The specification string consists of percentages, and the four
 characters: &lt; ^ &gt; |.  They mean:</p>

 <dl>
 <dt>30% (or any percentage)</dt>
 <dd>Move right by 30% of the width of the page.  If you skip
 right by more than 100%, there won't be any error, but you
 won't see anything printed off the right edge.  Non-integer
 percentages (e.g., <code>"33.3%"</code>) are perfectly legal.</dd>

 <dt>&gt;</dt>
 <dd>Some left-aligned text goes here.</dd>

 <dt>^</dt>
 <dd>Some center-aligned text goes here.</dd>

 <dt>&lt;</dt>
 <dd>Some right-aligned text goes here.</dd>

 <dt>|</dt>
 <dd>Draw a vertical bar here.  It's the full height of the line,
 so if you add multiple lines from this factory in a row, they'll
 connect all the way down your table.</dd>
 </dl>

 <p>(Extra whitespace in the spec string is ignored.)</p>

 <p>For example, the spec string <code>"> 50% | 50 <"</code> creates
 a table consisting of 2 columns: one left-aligned on the left half
 of the page, and one right-aligned on the right half of the page,
 with a vertical bar between them.</p>

 <p>A fancer example: <code>"10% | 2% > 38% | 2% > 38% | 10%"</code>
 makes a 2-column table, with both columns left-aligned, and vertical
 bars down the middle and on both sides.  (The extra 2% is there to
 prevent the text from running into the lines.)</p>

 <p>Once you've created a factory, how do you use it?  Simple!  Just
 call the <code>makeLine()</code> method, passing it a string with
 all of your table entries, separated by tab characters
 (<code>'\t'</code>).  To use the last example above:</p>

 <pre>
 // print a table of the numbers 1-5, along with their squares
 TabbedLineFactory f = new TabbedLineFactory("10% | 2% > 38% | 2% > 38% | 10%");
 lines.add(f.makeLine("n \t n squared"));
 for (int i=1; i<=5; i++)
 &nbsp;&nbsp;&nbsp;lines.add(f.makeLine(i + "\t" + i*i));
 </pre>

 @author Ken Harris &lt;kbh7 <i style="color: gray">at</i> cornell <i style="color: gray">dot</i> edu&gt;
 @version $Id$
 */
public class TabbedLineFactory {
	
	private static final String BAR = "|";
	private static final String LEFT = ">";
	private static final String CENTER = "^";
	private static final String RIGHT = "<";

	// list of BAR/LEFT/CENTER/RIGHT, or Number (meaning "skip this much")
	@SuppressWarnings("unchecked")
	private List tabs;

	private Font font = Line.NORMAL;

	/** Set the font to use for the lines generated by this factory.
	 @param f the font to use */
	public void setFont(Font f) {
		this.font = f;
	}

	// Q: do we want to allow setting this at any time?  we can be slightly more efficient if "no".

	/** Create a tabbed-line factory, given a line specification (see
	 above).
	 @param spec the line specification */
	@SuppressWarnings("unchecked")
	public TabbedLineFactory(String spec) {
		// parse spec
		StringTokenizer tok = new StringTokenizer(spec, " <>^|", true);
		int n = tok.countTokens();
		tabs = new ArrayList();

		for (int i = 0; i < n; i++) {
			String t = tok.nextToken();

			// skip whitespace (but i need to watch for it,
			// because it's a delimiter)
			if (t.trim().length() == 0)
				continue;

			// store |<>^ and %ages
			if (t.equals(BAR))
				tabs.add(BAR);
			else if (t.equals(LEFT))
				tabs.add(LEFT);
			else if (t.equals(CENTER))
				tabs.add(CENTER);
			else if (t.equals(RIGHT))
				tabs.add(RIGHT);
			else if (t.endsWith("%")) {
				tabs.add(new Float(t.substring(0, t.length() - 1)));
				// TODO: allow numbers sans '%' = point spacer, too
			} else
				throw new IllegalArgumentException();
		}

		// count the number of args i'm expecting.  this is very handy later.
		for (int i = 0; i < tabs.size(); i++) {
			if (tabs.get(i) instanceof String)
				expecting++;
		}
	}

	// the number of arguments i expect for each line.
	private int expecting = 0;

	// TODO: font style option, in addition to size?  (per factory, or per line?)
	// (per CELL would be ideal.  how hard would that be?)

	/**
	 Make a line, given the values of each element.

	 <p>The values should be separated by tab characters
	 (<code>'\t'</code>).  (Yes, that means you can't have tab
	 characters in your text.  Why would you want to?  What would it
	 mean?)</p>

	 <p>If you have fewer elements in this line than your spec
	 string expects, as many as you provide are used; beyond that,
	 blanks are used.  If you provide too many elements, as many are
	 expected are used (from the start of the string), and the rest
	 are ignored.</p>

	 @param values a string containing all of the values for this
	 line
	 */
	@SuppressWarnings("unchecked")
	public Line makeLine(String values) {
		final List val = new ArrayList();

		// (why not use a string tokenizer?  it has issues with tabs, especially
		// multiple tabs-in-a-row, or starts-with- or ends-with-a-tab.)
		String vals[] = StringUtils.splitBy(values, '\t');
		for (int i = 0; i < vals.length; i++) {
			vals[i] = vals[i].trim();
			// java bug: g.drawString("",x,y) throws illegal argument.
			if (vals[i].equals(""))
				vals[i] = " ";
		}
		// array->list
		for (int i = 0; i < vals.length; i++)
			val.add(vals[i]);

		// if there are fewer args than i'm expecting, add some blanks.
		int need = expecting - val.size();
		for (int i = 0; i < need; i++)
			val.add(" ");

		return new TabbedLine(val);
	}

	private class TabbedLine implements Line {
		@SuppressWarnings("unchecked")
		private List val;

		@SuppressWarnings("unchecked")
		TabbedLine(List val) {
			this.val = val;
		}

		public void print(Graphics g, PageFormat pf, float y) {
			// next value to use
			int next = 0;

			// next position to draw at (in % of total width)
			float position = 0f;

			// set font
			g.setFont(font);

			// boilerplate Line stuff
			float baseline = (y + g.getFontMetrics().getHeight());
			float left = (float) pf.getImageableX();
			float width = (float) pf.getImageableWidth();
			Graphics2D g2 = (Graphics2D) g;

			for (int i = 0; i < tabs.size(); i++) {
				if (tabs.get(i) instanceof Number) {
					// tab over
					position += ((Number) tabs.get(i)).floatValue();
				} else {
					// draw something here
					String tab = (String) tabs.get(i); // type of thing to draw
					float x = left + width * (position / 100f);

					if (tab.equals(LEFT)) {
						// draw val[next] left-aligned here
						g2.drawString(val.get(next++).toString(), x, baseline);
					} else if (tab.equals(CENTER)) {
						// draw val[next] center-aligned here
						float col = g.getFontMetrics().stringWidth(
								val.get(next).toString()); // width of this column's text
						g2.drawString(val.get(next++).toString(), x - col / 2,
								baseline);
					} else if (tab.equals(RIGHT)) {
						// draw val[next] right-aligned here
						float col = g.getFontMetrics().stringWidth(
								val.get(next).toString()); // width of this column's text
						g2.drawString(val.get(next++).toString(), x - col,
								baseline);
					} else if (tab.equals(BAR)) {
						// draw a vertical bar here
						g2.drawLine((int) x, (int) y, (int) x, (int) baseline);
					}
				}
			}
		}

		public int height(Graphics g) {
			return g.getFontMetrics(font).getHeight();
		}
	}
}
